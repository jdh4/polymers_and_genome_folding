"""This scripts numerically integrates a radial distribution
   function."""

# use sys for printing compatibility between Python 2 & 3
import sys
import math

# monomers per chain
monomers = 800

# input file (generated by rdf_loop.f90)
infile = '../' + str(monomers) + 'a/' + str(monomers) + 'dr0_25.out'

# output file (value of dr in embedded in file name)
outfile = 'neigh_' + str(monomers) + 'dr0_25.out'

# bin width (sigma)
dr = 0.25

# dictionary of N versus radius of gyration squared
N_Rgsq = {100:17.09, 200:29.73, 400:52.39, 800:85.62, 1600:146.23}
N_Resq = {100:50.54, 200:84.66, 400:150.36, 800:245.69, 1600:388.67}

# extract Rg/Re from dictionary
Re = N_Resq[monomers]**0.5

# number of chains
chains = 200

# monomer number density (sigma**-3)
rho = 0.85

# chain number density (sigma**-3)
rho_chains = chains / (monomers * chains / rho)

# prefactor for integration
fac = 4.0 * math.pi * rho_chains

# read and store file contents
f = open(infile)
lines = f.readlines()
f.close()

# load data
r = []; g = []
for line in lines:
  s = line.split()
  if(len(s) != 5):
    sys.stderr.write('WARNING: rows have different number of elements.')
  r.append(float(s[2]))
  g.append(float(s[3]))

# consistency check
if(abs((len(r) * dr - 0.5 * dr) / r[-1] - 1.0) > 0.01):
  sys.stderr.write('WARNING: possible bounds error.') 

# compute number of neighbors at r
f = open(outfile, 'w')
f.write('#i   r (sigma)   r/Re   g   neigh\n')
neigh = 0.0
for i in range(len(r)):
  neigh = neigh + fac * g[i] * r[i]**2 * dr
  f.write('%d %g %g %g %g\n' % (i, r[i], r[i] / Re, g[i], neigh))
f.close()
sys.stderr.write(outfile + ' has been written to disk.\n')
